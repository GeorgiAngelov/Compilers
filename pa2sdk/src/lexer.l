%{

// Include the header generated by bison for the token defs.
#include "parser.h"

%}

%option noyywrap
%option nounput
%option noinput

DIGIT             [0-9]
ID                [a-zA-Z][_a-zA-Z0-9]*

SHORT_COMP_OP     "<"|">"
ARITH_OP          "+"|"-"|"/"|"%"|"*"
BOOL_OP           "|"|"&"|"!"
ASSIGN            "="
PUNCTUATION       "("|")"|"["|"]"|"{"|"}"|":"|";"|","|"."
SHORT_TOK         {SHORT_COMP_OP}|{ARITH_OP}|{BOOL_OP}|{ASSIGN}|{PUNCTUATION}

%%

"/*"([^*]|("*"+([^*/])))*"*"+"/" { /* Eat multi-line comments. */ }

"//"[^\r\n]* { /* Eat single-line comments. */ }

"var"       { return VAR; }
"type"      { return TYPE; }
"function"  { return FUNCTION; }
"int"       { return INT; }
"bool"      { return BOOL; }

"for"       { return FOR; }
"to"        { return TO; }
"while"     { return WHILE; }
"if"        { return IF; }
"else"      { return ELSE; }
"return"    { return RETURN; }

"nil"       { return NIL; }
"true"      { return TRUE; }
"false"     { return FALSE; }

"<="        { return LT_EQ; }
">="        { return GT_EQ; }
"=="        { return EQ; }
"!="        { return NOT_EQ; }

{SHORT_TOK} { 
      // If a token stands for a single character, then we just use the value
      // of that character as the token.
      return *yytext;
}

{DIGIT}+    { return NUM; }

\"(\\\"|\\\\|[^"\r\n\\])*\" { return STR; }


"eval"      { return EVAL; /* Special token just for pa2. */ }

{ID}        { return ID; }

[ \n\r\t]+ { /* Eat up whitespace. */ }

. {
      fprintf(stderr, "Error: unrecognized character: %s\n", yytext);
      return UNKNOWN;
}

%%
