%code top {

#include <stdio.h>
#include <string.h>
#include "parser.h"

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header).
extern int yylex(void);

static void yyerror(const char*);

}

// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT BOOL
      ID STR NUM
      UNKNOWN
      EVAL
      PRINT

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="

// The type of yylval.
%union {
      int val;
};

// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: stmtlist
      | EVAL '(' expr ')' ';'	{printf ("Eval\n");}
      | EVAL '(' bexpr ')' ';'	{printf ("bEval\n");}

stmtlist: stmt stmtlist
		|
		
stmt: decls
    |  FUNCTION ID '(' paramlist ')' returntype '{' stmtlist '}' 	{printf ("function\n");}
	| IF '(' bexpr ')' '{' stmtlist '}' {printf ("IF statement\n");}
	| RETURN return_type ';' {printf("return\n");}
	| 

decls: VAR ID ':' DATA '=' expr ';' {printf ("Assignment with data\n");}
	|	VAR ID ':' DATA '=' array_assign ';' {printf ("Assignment with ARRAY\n");}
	|	PRINT '(' ID ')' 			{printf ("print\n");}
	|	VAR ID ':' '{' paramlist '}' ';'	{printf ("Structure\n");}
	|	VAR ID ':' DATA ';'			{printf ("Assignment without data\n");}
 
return_type:
			| '(' expr ')'
			
returntype: 
			| ':' DATA
 
exprlist: exprList2 
exprList2:
		|	expr1 expr2
expr1: expr
expr2: 
		| ',' expr expr2
		
expr: '(' expr ')'
	|	NUM 				{printf ("NUM\n");}
	|	expr '+' expr 		{printf ("plus\n");}
	|	expr '-' expr		{printf ("minus\n");}
	|	expr '*' expr		{printf ("times\n");}
	|	expr '/' expr		{printf ("division\n");}
	|	expr '%' expr		{printf ("modulus\n");}
	|	ID '(' exprlist ')'	{printf ("functioncall\n");}
	|	ID					{printf ("ID\n");} 

bexpr: TRUE					{printf ("TRUE\n");}
	|	FALSE				{printf ("FALSE\n");}
	|	bexpr '&' bexpr		{printf ("AND\n");}
	|	bexpr '|' bexpr		{printf ("OR\n");}
	| 	expr EQ expr		{printf ("EQ\n");}
	|	expr NOT_EQ expr	{printf ("NOTEQ\n");}
	|	expr LT_EQ expr		{printf ("LTEQ\n");}
	| 	expr GT_EQ expr		{printf ("GTEQ\n");}
	|	expr '>' expr		{printf ("GT\n");}
	|	expr '<' expr		{printf ("LT\n");}
	| 	'!' bexpr			{printf ("NOT\n");}

paramlist: paramlist2

paramlist2 : 
			| P1 P2
	
P1: ID ':' DATA

P2: 
	| ','  ID ':' DATA P2

DATA: INT
	| ARRAY
	| ID

ARRAY: '[' DATA ']'

array_assign: 
	|'[' array_data ']'
	
array_data: INT {printf

val1:	ID {printf("val1 ID\n");}
	|	INT {printf("val1 INT\n");}
	|	array_assign  {printf("val1 ARRAY_ASSIGN\n");}

val2: ',' ID val2 {printf("val2 ID\n");}
	|	',' INT val2 {printf("val2 INT\n");}
	|	',' array_assign val2 {printf("val2 ARRAY_ASSIGN\n");}
	| {printf("val2 NULL\n");}
	
%%

void yyerror(const char* p) {
      fprintf(stderr, "%s\n", p);
}