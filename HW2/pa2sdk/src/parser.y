%code top {

#include <stdio.h>
#include <string.h>
#include "parser.h"

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header).
extern int yylex(void);

static void yyerror(const char*);

}

// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT BOOL
      ID STR NUM
      UNKNOWN
      EVAL
      PRINT

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="

// The type of yylval.
%union {
      int val;
};

// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: stmtlist
      | EVAL '(' expr ')' ';'	{printf ("Eval\n");}
      | EVAL '(' bexpr ')' ';'	{printf ("bEval\n");}

stmtlist: stmt stmtlist
		|

stmt: decls
    |  FUNCTION ID '(' paramlist ')' returntype '{' functionbody '}' 	{printf ("function\n");}

decls:  VAR ID ':' INT '=' expr ';' {printf ("Assignment\n");}
     | PRINT '(' ID ')' 			{printf ("print\n");}
     
    
functionbody: RETURN '(' expr ')' ';'	{printf ("return\n");}
			|

returntype: 
			| ':' INT
 
exprlist: expr exprlist 
		|
    
expr: '(' expr ')'		
	|	NUM 				{printf ("NUM\n");}
	|	expr '+' expr 		{printf ("plus\n");}
	|	expr '-' expr		{printf ("minus\n");}
	|	expr '*' expr		{printf ("times\n");}
	|	expr '/' expr		{printf ("division\n");}
	|	ID '(' exprlist ')'	{printf ("functioncall\n");}
	|	ID					{printf ("ID\n");}



bexpr: TRUE					{printf ("TRUE\n");}
	|	FALSE				{printf ("FALSE\n");}
	|	bexpr '&' bexpr		{printf ("AND\n");}
	|	bexpr '|' bexpr		{printf ("OR\n");}
	| 	expr EQ expr		{printf ("EQ\n");}
	|	expr NOT_EQ expr	{printf ("NOTEQ\n");}
	|	expr LT_EQ expr		{printf ("LTEQ\n");}
	| 	expr GT_EQ expr		{printf ("GTEQ\n");}
	| 	'!' bexpr			{printf ("NOT\n");}

paramlist: paramlist2

paramlist2 : 
			| P1 P2
	
P1: ID ':' INT

P2: 
	| ','  ID ':' INT P2

%%

void yyerror(const char* p) {
      fprintf(stderr, "%s\n", p);
}