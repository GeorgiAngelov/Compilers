%code top {

#include <stdio.h>
#include <string.h>
#include "parser.h"
#include <iostream>
#include <unordered_map>
using namespace std;

typedef struct fundata {
	std::string name;
	int parity;
	int references;
	int declared;
} funData;

// Defined in the C file generated by flex. We can't include lexer.h because
// that'd cause a circular dependency (we need the header generated by bison to
// generate the lexer.h header).
extern int yylex(void);
int result;

std::unordered_map<std::string, funData> function_map;

static void yyerror(const char*);

}

// The type of yylval.
%union {
      int val;
      int num;
      char* text;
      int boolean;
};

// These get stuck in a token enum in the header bison generates (parser.h),
// which we can then include in our lexer spec.
%token VAR TYPE FUNCTION
      FOR TO WHILE IF ELSE RETURN
      NIL TRUE FALSE
      INT <boolean>BOOL
      <text>ID STR <num>NUM
      UNKNOWN
      EVAL
      PRINT

// These associate tokens with string lits like "<=" so we can use them in our
// grammar.
%token LT_EQ "<="
%token GT_EQ ">="
%token EQ "=="
%token NOT_EQ "!="



%type <num> expr
%type <boolean> bexpr
%type <num> paramlist
%type <num> P1
%type <num> P2

// The top-level rule.
%start program

%%

// A Liger program is either a list of declarations or it's an "extended Liger"
// program -- an EVAL token followed by a Liger expression.
program: stmtlist
      | EVAL '(' expr ')' ';'	{result = $3;}
      | EVAL '(' bexpr ')' ';'	{if ($3 == 1){printf ("Result: True\n");}else{printf("Result: False\n");}}

stmtlist: stmt stmtlist
		|

stmt: decls
    |  FUNCTION ID '(' paramlist ')' returntype '{' functionbody '}' 	{funData temp; 
    																	temp.name = $2; 
    																	temp.parity = $4; 
    																	temp.references = 0; 
    																	temp.declared = 1;
    																	function_map[$2] = temp;}

decls:  VAR ID ':' INT '=' expr ';' {printf ("Assignment\n");}
     | PRINT '(' ID ')' 			{printf ("print\n");}
     
    
functionbody: RETURN '(' expr ')' ';'	{printf ("return\n");}
			|

returntype: 
			| ':' INT
 
exprlist: exprList2 
exprList2:
		|	expr1 expr2
expr1: expr
expr2: 
		| ',' expr expr2
		
expr: '(' expr ')'			{$$=$2;}
	|	NUM 				{$$=$1;}
	|	expr '+' expr 		{$$= $1 + $3;}
	|	expr '-' expr		{$$= $1 - $3;}
	|	expr '*' expr		{$$= $1 * $3;}
	|	expr '/' expr		{$$= $1 / $3;}
	|	ID '(' exprlist ')'	{}
	|	ID					{}



bexpr: TRUE					{$$= 1;}
	|	FALSE				{$$= 0;}
	|	bexpr '&' bexpr		{$$= $1 && $3;}
	|	bexpr '|' bexpr		{$$= $1 || $3;}
	| 	expr EQ expr		{$$= $1 == $3;}
	|	expr NOT_EQ expr	{$$= $1 != $3;}
	|	expr LT_EQ expr		{$$= $1 <= $3;}
	| 	expr GT_EQ expr		{$$= $1 >= $3;}
	| 	'!' bexpr			{$$= !$2;}

paramlist:	{$$=0;}
			| P1 P2 {$$=$1 + $2;}
	
P1: ID ':' INT {$$=1;}

P2: {$$=0;}
	| ','  ID ':' INT P2 {$$= $5 + 1;}

%%

void yyerror(const char* p) {
      fprintf(stderr, "%s\n", p);
}
